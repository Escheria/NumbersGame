//cache these
var contentWrapper = $("#wrapper");
var sidebarWrapper = $("#sidebar-wrapper");

$("#menu-toggle").click(function (e) {
  e.preventDefault();

  contentWrapper.toggleClass("toggled");

  //beats me why the initial thing is reversed, cause toggled?
  // if(sidebarWrapper.css('width') === '0px'){
  //   $('.menuButtonText').text('Close');
  // } else {
  //   $('.menuButtonText').text('View Rules');
  // }
});

$(document).ready(function () {
  // if($("#sidebar-wrapper").css('width') === '0px'){
  //   $('.menuButtonText').text('View Rules');
  // } else {
  //   $('.menuButtonText').text('Close');
  // }
  ReactDOM.render(React.createElement(Board, null), document.getElementById('mount-game'));
});

//--------------------------------- GAME -------------------------------------------

function AyyNumbersGame() {
  var initial = [[1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 2, 1, 3, 1, 4, 1], [5, 1, 6, 1, 7, 1, 8, 1, 9]];

  var increment = [[1, 2, 3, 4, 5, 6, 7, 8, 9], [1, 1, 1, 2, 1, 3, 1, 4, 1], [5, 1, 6, 1, 7, 1, 8, 1, 9]];

  this.getInitialState = function () {
    return {
      items: mapToObjects(initial),
      deleteCell: false,
      deletedCells: 0
    };
  };

  var board = this.getInitialState().items;

  var boardUI = null;

  var selection = null;

  this.setGameBoardUI = function (board) {
    boardUI = board;
  };

  /*
    Functions to help position validation
    -1 = first cell
     0 = any cell
     1 = second cell
   */
  function compareCells(A, B) {
    if (A.x === B.x && A.y === B.y) {
      return 0;
    }
    if (A.y <= B.y) {
      if (A.x <= B.x) {
        return -1;
      }
    } else {
      if (A.x < B.x) {
        return -1;
      }
    }
    return 1;
  }

  function checkHorizontal(A, B) {
    for (var i = A.x + 1; i <= B.x; i++) {
      //skip until we get to B.x or something else
      if (board[A.y][i] === null) {
        continue;
      }
      if (i !== B.x) {
        return false;
      }
    }
    return true;
  }

  function checkVertical(A, B) {
    for (var x = A.x; x <= B.x || x < board[0].length; x++) {
      //Wanna start with A.y on first iteration, then from 0 if we move on to next column
      //So if we are on initial column X, start at A.y, later at 0
      for (var y = x === A.x ? A.y : 0; y <= B.y || y < board.length; y++) {
        //skip until we get to B or something else
        if (board[y][x] === null || x === A.x && y === A.y) {
          continue;
        }
        if (x !== B.x || y !== B.y) {
          return false;
        }
        if (x === B.x && y === B.y) {
          return true;
        }
      }
    }
    return true;
  }

  /*
    Check validity of two cells when their sum is as requested.
    One of the main game logic elements.
   */
  function checkPosition(A, B) {
    var cell = compareCells(A, B);
    if (A.y === B.y) {
      //just a special, easier case
      return cell < 0 ? checkHorizontal(A, B) : checkHorizontal(B, A);
    } else {
      return cell < 0 ? checkVertical(A, B) : checkVertical(B, A);
    }

    return false;
  }

  /*
  -#: Cell Selected
  null
   */
  this.markCell = function (x, y) {
    //delete cell mode overrides it all
    if (this.deleteAnyMode) {
      selection = null; //deselect old one
      board[y][x] = null;
      tilesDeleted++;
      this.deleteAnyMode = false;
      cellsLeft--;
      return boardUI.updateBoardState(board);
    }

    //deselect
    if (selection && x === selection.x && y === selection.y) {
      //TODO: Remove minus once rendering is OK
      board[y][x].data = -board[y][x].data;
      selection = null;
      return boardUI.updateBoardState(board);
    }
    //first selection
    if (selection === null) {
      board[y][x].data = -board[y][x].data;
      selection = { 'x': x, 'y': y };
    } else {
      var A = board[y][x].data;
      var B = -board[selection.y][selection.x].data;
      //Potential cells to cross
      if (A + B === 10 || A === B) {
        //Positions must adhere to rules
        if (checkPosition(selection, { 'x': x, 'y': y })) {
          board[y][x] = null;
          board[selection.y][selection.x] = null;
          selection = null;
          cellsLeft -= 2;
        }
      } else {
        //deselect
        board[selection.y][selection.x].data = -board[selection.y][selection.x].data;
        selection = null;
      }
    } //first selection
    boardUI.updateBoardState(board);
  };

  this.addRows = function () {
    var mappedIncrement = mapToObjects(increment);
    for (var row in mappedIncrement) {
      board = board.concat([mappedIncrement[row]]);
    }
    cellsLeft += cellsInc;
    return board;
  };

  /*
    Map a simple representation of the 
    board to a data+key
   */
  function mapToObjects(array) {
    return array.map(function (item) {
      return item.map(function (cell) {
        return { "data": cell, "key": generateUUID() };
      });
    });
  }

  //------------ DELETE ANY CELL MODE ------------
  this.deleteAnyMode = false;

  var tilesDeleted = 0;
  var tilesDeletedMax = 3;

  this.getTilesDeleted = function () {
    return tilesDeletedMax - tilesDeleted;
  };

  this.canDeleteCells = function () {
    return tilesDeleted < tilesDeletedMax;
  };

  this.toggleDeleteMode = function () {
    if (!this.canDeleteCells()) {
      this.deleteAnyMode = false;
      return;
    }
    this.deleteAnyMode = !this.deleteAnyMode;
    return this.deleteAnyMode;
  };

  //------------ WIN CONDITION ------------
  var cellsLeft = board.length * board[0].length;
  var cellsInc = cellsLeft;

  //if we never usee the wildcards, then we win if there is one tile left
  this.didWeWin = function () {
    return cellsLeft < 2;
  };

  this.cellsRemaining = function () {
    return cellsLeft;
  };
}
var numbersGame = new AyyNumbersGame();

//--------------------------------- GUI --------------------------------------------
var Toolbar = React.createClass({
  displayName: "Toolbar",


  render: function () {
    var btnClass = '';

    if (!this.props.canDeleteCells) {
      btnClass = 'inactive'; //"btn-danger";
    } else if (this.props.deleteTileOff) {
        btnClass = 'active'; //"btn-warning";
      }

    return React.createElement(
      "div",
      { className: "toolbar-container" },
      React.createElement(
        "button",
        { className: "btn btn-toolbar ", onClick: this.props.addRows },
        "Add more rows"
      ),
      React.createElement("span", { className: "spacer-tiny" }),
      React.createElement(
        "button",
        { className: "btn btn-toolbar " + btnClass, onClick: this.props.toggleDeleteMode },
        "Remove any Cell (" + this.props.cellsLeft + ")"
      )
    );
  }

});

var Board = React.createClass({
  displayName: "Board",

  getInitialState: function () {
    var state = numbersGame.getInitialState();
    return state;
  },

  updateBoardState: function (newBoardState) {
    this.setState({
      items: newBoardState,
      deleteTile: numbersGame.deleteAnyMode
    });
  },

  toggleDeleteMode: function () {
    this.setState({
      items: this.state.items,
      deleteTile: numbersGame.toggleDeleteMode()
    });
  },

  addRows: function () {
    this.setState({
      items: numbersGame.addRows(),
      deleteTile: this.state.deleteTile
    });
  },

  render: function () {
    var itemMap = this.state.items;
    numbersGame.setGameBoardUI(this);
    var winMessage = '';
    //if we win:
    if (numbersGame.didWeWin()) {
      winMessage = ' - You Win!';
      setTimeout(function () {
        $('#myModal').modal('show');
      }, 100);
    }

    // setTimeout(function(){
    //   $('#myModal').modal('show');
    // }, 100);

    var needBottomToolbar = itemMap.length > 8 ? true : false;

    /* <span>Cells left: {numbersGame.cellsRemaining()} {winMessage}</span> */

    return React.createElement(
      "div",
      null,
      React.createElement(Toolbar, { addRows: this.addRows, toggleDeleteMode: this.toggleDeleteMode, cellsLeft: numbersGame.getTilesDeleted(),
        deleteTileOff: this.state.deleteTile, canDeleteCells: numbersGame.canDeleteCells() }),
      React.createElement(
        "div",
        { className: "board" },
        React.createElement(
          "ul",
          null,
          itemMap.map(function (item, idx) {
            var k = generateUUID();
            return React.createElement(Row, { rowKey: k, key: k, rownum: idx, data: item });
          })
        )
      ),
      needBottomToolbar ? React.createElement(Toolbar, { addRows: this.addRows, toggleDeleteMode: this.toggleDeleteMode, cellsLeft: numbersGame.getTilesDeleted(),
        deleteTileOff: this.state.deleteTile, canDeleteCells: numbersGame.canDeleteCells() }) : ''
    );
  }
});

var Row = React.createClass({
  displayName: "Row",

  checkRowComplete: function () {
    for (var item in this.props.data) {
      if (item !== null) {
        return false;
      }
    }
    return true;
  },
  render: function () {
    var rowData = this.props.data;
    var rowNum = this.props.rownum;
    return React.createElement(
      "li",
      { "data-rowKey": this.props.rowKey, Key: this.props.rowKey },
      rowData.map(function (item, idx) {
        var uuid = generateUUID();
        var data = item !== null ? item.data : null;
        return React.createElement(Cell, { key: uuid, cellId: uuid, x: idx, y: rowNum, value: data });
      })
    );
  }
});

//x = cell number, y = row number
var Cell = React.createClass({
  displayName: "Cell",

  doTurn: function () {
    if (this.props.value === null) {
      return;
    }
    numbersGame.markCell(this.props.x, this.props.y);
  },
  render: function () {
    var renderMode = this.props.value;
    var cellValue = this.props.value;
    var cellClasses = 'btn-numbers';
    if (renderMode === null) {
      cellClasses = 'btn-crossed'; //'btn btn-default crossed'
    } else if (renderMode < 0) {
        cellValue = -cellValue;
        cellClasses = 'btn-selected'; //"btn btn-warning";
      }
    return(
      /*<button onClick={this.doTurn} data-cell={this.props.cellId} x={this.props.x} y={this.props.y} className={"cell btn "+cellClasses} data-cell={this.props.cellId}>{cellValue}</button>*/
      React.createElement(
        "div",
        { onClick: this.doTurn, className: "box", x: this.props.x, y: this.props.y, "data-cell": this.props.cellId, "data-cell": this.props.cellId },
        React.createElement(
          "div",
          { className: "cell btn content " + cellClasses },
          React.createElement(
            "span",
            { className: "adjust" },
            cellValue
          )
        )
      )
    );
    //<button onClick={this.doTurn} data-cell={this.props.cellId} x={this.props.x} y={this.props.y} className={"cell "+cellClasses} data-cell={this.props.cellId}>{cellValue}</button>
  }
});
//--------------------------------- MISC -------------------------------------------
/*
http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript

Here's a similar RFC4122 version 4 compliant solution that solves that issue by
offsetting the first 13 hex numbers by a hex portion of the timestamp. That way,
even if Math.random is on the same seed, both clients would have to generate the
UUID at the exact same millisecond (or 10,000+ years later) to get the same UUID:
 */
function generateUUID() {
  var d = new Date().getTime();
  if (window.performance && typeof window.performance.now === "function") {
    d += performance.now(); //use high-precision timer if available
  }
  var uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
    var r = (d + Math.random() * 16) % 16 | 0;
    d = Math.floor(d / 16);
    return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);
  });
  return uuid;
}
//# sourceMappingURL=app.js.map
